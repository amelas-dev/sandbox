{
  "version": 3,
  "sources": ["../../@tiptap/extension-table/src/utilities/colStyle.ts", "../../@tiptap/extension-table/src/TableView.ts", "../../@tiptap/extension-table/src/utilities/createColGroup.ts", "../../@tiptap/extension-table/src/utilities/createCell.ts", "../../@tiptap/extension-table/src/utilities/getTableNodeTypes.ts", "../../@tiptap/extension-table/src/utilities/createTable.ts", "../../@tiptap/extension-table/src/utilities/isCellSelection.ts", "../../@tiptap/extension-table/src/utilities/deleteTableWhenAllCellsSelected.ts", "../../@tiptap/extension-table/src/table.ts"],
  "sourcesContent": ["export function getColStyleDeclaration(minWidth: number, width: number | undefined): [string, string] {\n  if (width) {\n    // apply the stored width unless it is below the configured minimum cell width\n    return ['width', `${Math.max(width, minWidth)}px`]\n  }\n\n  // set the minimum with on the column if it has no stored width\n  return ['min-width', `${minWidth}px`]\n\n}\n", "import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { NodeView, ViewMutationRecord } from '@tiptap/pm/view'\n\nimport { getColStyleDeclaration } from './utilities/colStyle.js'\n\nexport function updateColumns(\n  node: ProseMirrorNode,\n  colgroup: HTMLTableColElement, // <colgroup> has the same prototype as <col>\n  table: HTMLTableElement,\n  cellMinWidth: number,\n  overrideCol?: number,\n  overrideValue?: number,\n) {\n  let totalWidth = 0\n  let fixedWidth = true\n  let nextDOM = colgroup.firstChild\n  const row = node.firstChild\n\n  if (row !== null) {\n    for (let i = 0, col = 0; i < row.childCount; i += 1) {\n      const { colspan, colwidth } = row.child(i).attrs\n\n      for (let j = 0; j < colspan; j += 1, col += 1) {\n        const hasWidth = overrideCol === col ? overrideValue : (colwidth && colwidth[j]) as number | undefined\n        const cssWidth = hasWidth ? `${hasWidth}px` : ''\n\n        totalWidth += hasWidth || cellMinWidth\n\n        if (!hasWidth) {\n          fixedWidth = false\n        }\n\n        if (!nextDOM) {\n          const colElement = document.createElement('col')\n\n          const [propertyKey, propertyValue] = getColStyleDeclaration(cellMinWidth, hasWidth)\n\n          colElement.style.setProperty(propertyKey, propertyValue)\n\n          colgroup.appendChild(colElement)\n        } else {\n          if ((nextDOM as HTMLTableColElement).style.width !== cssWidth) {\n            const [propertyKey, propertyValue] = getColStyleDeclaration(cellMinWidth, hasWidth);\n\n            (nextDOM as HTMLTableColElement).style.setProperty(propertyKey, propertyValue)\n          }\n\n          nextDOM = nextDOM.nextSibling\n        }\n      }\n    }\n  }\n\n  while (nextDOM) {\n    const after = nextDOM.nextSibling\n\n    nextDOM.parentNode?.removeChild(nextDOM)\n    nextDOM = after\n  }\n\n  if (fixedWidth) {\n    table.style.width = `${totalWidth}px`\n    table.style.minWidth = ''\n  } else {\n    table.style.width = ''\n    table.style.minWidth = `${totalWidth}px`\n  }\n}\n\nexport class TableView implements NodeView {\n  node: ProseMirrorNode\n\n  cellMinWidth: number\n\n  dom: HTMLDivElement\n\n  table: HTMLTableElement\n\n  colgroup: HTMLTableColElement\n\n  contentDOM: HTMLTableSectionElement\n\n  constructor(node: ProseMirrorNode, cellMinWidth: number) {\n    this.node = node\n    this.cellMinWidth = cellMinWidth\n    this.dom = document.createElement('div')\n    this.dom.className = 'tableWrapper'\n    this.table = this.dom.appendChild(document.createElement('table'))\n    this.colgroup = this.table.appendChild(document.createElement('colgroup'))\n    updateColumns(node, this.colgroup, this.table, cellMinWidth)\n    this.contentDOM = this.table.appendChild(document.createElement('tbody'))\n  }\n\n  update(node: ProseMirrorNode) {\n    if (node.type !== this.node.type) {\n      return false\n    }\n\n    this.node = node\n    updateColumns(node, this.colgroup, this.table, this.cellMinWidth)\n\n    return true\n  }\n\n  ignoreMutation(mutation: ViewMutationRecord) {\n    return (\n      mutation.type === 'attributes'\n      && (mutation.target === this.table || this.colgroup.contains(mutation.target))\n    )\n  }\n}\n", "import { DOMOutputSpec, Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { getColStyleDeclaration } from './colStyle.js'\n\nexport type ColGroup = {\n  colgroup: DOMOutputSpec\n  tableWidth: string\n  tableMinWidth: string\n} | Record<string, never>;\n\n/**\n * Creates a colgroup element for a table node in ProseMirror.\n *\n * @param node - The ProseMirror node representing the table.\n * @param cellMinWidth - The minimum width of a cell in the table.\n * @param overrideCol - (Optional) The index of the column to override the width of.\n * @param overrideValue - (Optional) The width value to use for the overridden column.\n * @returns An object containing the colgroup element, the total width of the table, and the minimum width of the table.\n */\nexport function createColGroup(\n  node: ProseMirrorNode,\n  cellMinWidth: number,\n): ColGroup\nexport function createColGroup(\n  node: ProseMirrorNode,\n  cellMinWidth: number,\n  overrideCol: number,\n  overrideValue: number,\n): ColGroup\nexport function createColGroup(\n  node: ProseMirrorNode,\n  cellMinWidth: number,\n  overrideCol?: number,\n  overrideValue?: number,\n): ColGroup {\n  let totalWidth = 0\n  let fixedWidth = true\n  const cols: DOMOutputSpec[] = []\n  const row = node.firstChild\n\n  if (!row) {\n    return {}\n  }\n\n  for (let i = 0, col = 0; i < row.childCount; i += 1) {\n    const { colspan, colwidth } = row.child(i).attrs\n\n    for (let j = 0; j < colspan; j += 1, col += 1) {\n      const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j] as number | undefined\n\n      totalWidth += hasWidth || cellMinWidth\n\n      if (!hasWidth) {\n        fixedWidth = false\n      }\n\n      const [property, value] = getColStyleDeclaration(cellMinWidth, hasWidth)\n\n      cols.push([\n        'col',\n        { style: `${property}: ${value}` },\n      ])\n    }\n  }\n\n  const tableWidth = fixedWidth ? `${totalWidth}px` : ''\n  const tableMinWidth = fixedWidth ? '' : `${totalWidth}px`\n\n  const colgroup: DOMOutputSpec = ['colgroup', {}, ...cols]\n\n  return { colgroup, tableWidth, tableMinWidth }\n}\n", "import { Fragment, Node as ProsemirrorNode, NodeType } from '@tiptap/pm/model'\n\nexport function createCell(\n  cellType: NodeType,\n  cellContent?: Fragment | ProsemirrorNode | Array<ProsemirrorNode>,\n): ProsemirrorNode | null | undefined {\n  if (cellContent) {\n    return cellType.createChecked(null, cellContent)\n  }\n\n  return cellType.createAndFill()\n}\n", "import { NodeType, Schema } from '@tiptap/pm/model'\n\nexport function getTableNodeTypes(schema: Schema): { [key: string]: NodeType } {\n  if (schema.cached.tableNodeTypes) {\n    return schema.cached.tableNodeTypes\n  }\n\n  const roles: { [key: string]: NodeType } = {}\n\n  Object.keys(schema.nodes).forEach(type => {\n    const nodeType = schema.nodes[type]\n\n    if (nodeType.spec.tableRole) {\n      roles[nodeType.spec.tableRole] = nodeType\n    }\n  })\n\n  schema.cached.tableNodeTypes = roles\n\n  return roles\n}\n", "import { Fragment, Node as ProsemirrorNode, Schema } from '@tiptap/pm/model'\n\nimport { createCell } from './createCell.js'\nimport { getTableNodeTypes } from './getTableNodeTypes.js'\n\nexport function createTable(\n  schema: Schema,\n  rowsCount: number,\n  colsCount: number,\n  withHeaderRow: boolean,\n  cellContent?: Fragment | ProsemirrorNode | Array<ProsemirrorNode>,\n): ProsemirrorNode {\n  const types = getTableNodeTypes(schema)\n  const headerCells: ProsemirrorNode[] = []\n  const cells: ProsemirrorNode[] = []\n\n  for (let index = 0; index < colsCount; index += 1) {\n    const cell = createCell(types.cell, cellContent)\n\n    if (cell) {\n      cells.push(cell)\n    }\n\n    if (withHeaderRow) {\n      const headerCell = createCell(types.header_cell, cellContent)\n\n      if (headerCell) {\n        headerCells.push(headerCell)\n      }\n    }\n  }\n\n  const rows: ProsemirrorNode[] = []\n\n  for (let index = 0; index < rowsCount; index += 1) {\n    rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells))\n  }\n\n  return types.table.createChecked(null, rows)\n}\n", "import { CellSelection } from '@tiptap/pm/tables'\n\nexport function isCellSelection(value: unknown): value is CellSelection {\n  return value instanceof CellSelection\n}\n", "import { findParentNodeClosestToPos, KeyboardShortcutCommand } from '@tiptap/core'\n\nimport { isCellSelection } from './isCellSelection.js'\n\nexport const deleteTableWhenAllCellsSelected: KeyboardShortcutCommand = ({ editor }) => {\n  const { selection } = editor.state\n\n  if (!isCellSelection(selection)) {\n    return false\n  }\n\n  let cellCount = 0\n  const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {\n    return node.type.name === 'table'\n  })\n\n  table?.node.descendants(node => {\n    if (node.type.name === 'table') {\n      return false\n    }\n\n    if (['tableCell', 'tableHeader'].includes(node.type.name)) {\n      cellCount += 1\n    }\n  })\n\n  const allCellsSelected = cellCount === selection.ranges.length\n\n  if (!allCellsSelected) {\n    return false\n  }\n\n  editor.commands.deleteTable()\n\n  return true\n}\n", "import {\n  callOrReturn, getExtensionField, mergeAttributes, Node, ParentConfig,\n} from '@tiptap/core'\nimport { DOMOutputSpec, Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { TextSelection } from '@tiptap/pm/state'\nimport {\n  addColumnAfter,\n  addColumnBefore,\n  addRowAfter,\n  addRowBefore,\n  CellSelection,\n  columnResizing,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  fixTables,\n  goToNextCell,\n  mergeCells,\n  setCellAttr,\n  splitCell,\n  tableEditing,\n  toggleHeader,\n  toggleHeaderCell,\n} from '@tiptap/pm/tables'\nimport { EditorView, NodeView } from '@tiptap/pm/view'\n\nimport { TableView } from './TableView.js'\nimport { createColGroup } from './utilities/createColGroup.js'\nimport { createTable } from './utilities/createTable.js'\nimport { deleteTableWhenAllCellsSelected } from './utilities/deleteTableWhenAllCellsSelected.js'\n\nexport interface TableOptions {\n  /**\n   * HTML attributes for the table element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Enables the resizing of tables.\n   * @default false\n   * @example true\n   */\n  resizable: boolean\n\n  /**\n   * The width of the resize handle.\n   * @default 5\n   * @example 10\n   */\n  handleWidth: number\n\n  /**\n   * The minimum width of a cell.\n   * @default 25\n   * @example 50\n   */\n  cellMinWidth: number\n\n  /**\n   * The node view to render the table.\n   * @default TableView\n   */\n  View: (new (node: ProseMirrorNode, cellMinWidth: number, view: EditorView) => NodeView) | null\n\n  /**\n   * Enables the resizing of the last column.\n   * @default true\n   * @example false\n   */\n  lastColumnResizable: boolean\n\n  /**\n   * Allow table node selection.\n   * @default false\n   * @example true\n   */\n  allowTableNodeSelection: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    table: {\n      /**\n       * Insert a table\n       * @param options The table attributes\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.insertTable({ rows: 3, cols: 3, withHeaderRow: true })\n       */\n      insertTable: (options?: {\n        rows?: number\n        cols?: number\n        withHeaderRow?: boolean\n      }) => ReturnType\n\n      /**\n       * Add a column before the current column\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.addColumnBefore()\n       */\n      addColumnBefore: () => ReturnType\n\n      /**\n       * Add a column after the current column\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.addColumnAfter()\n       */\n      addColumnAfter: () => ReturnType\n\n      /**\n       * Delete the current column\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.deleteColumn()\n       */\n      deleteColumn: () => ReturnType\n\n      /**\n       * Add a row before the current row\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.addRowBefore()\n       */\n      addRowBefore: () => ReturnType\n\n      /**\n       * Add a row after the current row\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.addRowAfter()\n       */\n      addRowAfter: () => ReturnType\n\n      /**\n       * Delete the current row\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.deleteRow()\n       */\n      deleteRow: () => ReturnType\n\n      /**\n       * Delete the current table\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.deleteTable()\n       */\n      deleteTable: () => ReturnType\n\n      /**\n       * Merge the currently selected cells\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.mergeCells()\n       */\n      mergeCells: () => ReturnType\n\n      /**\n       * Split the currently selected cell\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.splitCell()\n       */\n      splitCell: () => ReturnType\n\n      /**\n       * Toggle the header column\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.toggleHeaderColumn()\n       */\n      toggleHeaderColumn: () => ReturnType\n\n      /**\n       * Toggle the header row\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.toggleHeaderRow()\n       */\n      toggleHeaderRow: () => ReturnType\n\n      /**\n       * Toggle the header cell\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.toggleHeaderCell()\n       */\n      toggleHeaderCell: () => ReturnType\n\n      /**\n       * Merge or split the currently selected cells\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.mergeOrSplit()\n       */\n      mergeOrSplit: () => ReturnType\n\n      /**\n       * Set a cell attribute\n       * @param name The attribute name\n       * @param value The attribute value\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.setCellAttribute('align', 'right')\n       */\n      setCellAttribute: (name: string, value: any) => ReturnType\n\n      /**\n       * Moves the selection to the next cell\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.goToNextCell()\n       */\n      goToNextCell: () => ReturnType\n\n      /**\n       * Moves the selection to the previous cell\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.goToPreviousCell()\n       */\n      goToPreviousCell: () => ReturnType\n\n      /**\n       * Try to fix the table structure if necessary\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.fixTables()\n       */\n      fixTables: () => ReturnType\n\n      /**\n       * Set a cell selection inside the current table\n       * @param position The cell position\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.setCellSelection({ anchorCell: 1, headCell: 2 })\n       */\n      setCellSelection: (position: { anchorCell: number; headCell?: number }) => ReturnType\n    }\n  }\n\n  interface NodeConfig<Options, Storage> {\n    /**\n     * A string or function to determine the role of the table.\n     * @default 'table'\n     * @example () => 'table'\n     */\n    tableRole?:\n      | string\n      | ((this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options>>['tableRole']\n    }) => string)\n  }\n}\n\n/**\n * This extension allows you to create tables.\n * @see https://www.tiptap.dev/api/nodes/table\n */\nexport const Table = Node.create<TableOptions>({\n  name: 'table',\n\n  // @ts-ignore\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      resizable: false,\n      handleWidth: 5,\n      cellMinWidth: 25,\n      // TODO: fix\n      View: TableView,\n      lastColumnResizable: true,\n      allowTableNodeSelection: false,\n    }\n  },\n\n  content: 'tableRow+',\n\n  tableRole: 'table',\n\n  isolating: true,\n\n  group: 'block',\n\n  parseHTML() {\n    return [{ tag: 'table' }]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    const { colgroup, tableWidth, tableMinWidth } = createColGroup(\n      node,\n      this.options.cellMinWidth,\n    )\n\n    const table: DOMOutputSpec = [\n      'table',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n        style: tableWidth\n          ? `width: ${tableWidth}`\n          : `min-width: ${tableMinWidth}`,\n      }),\n      colgroup,\n      ['tbody', 0],\n    ]\n\n    return table\n  },\n\n  addCommands() {\n    return {\n      insertTable:\n        ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch, editor }) => {\n          const node = createTable(editor.schema, rows, cols, withHeaderRow)\n\n          if (dispatch) {\n            const offset = tr.selection.from + 1\n\n            tr.replaceSelectionWith(node)\n              .scrollIntoView()\n              .setSelection(TextSelection.near(tr.doc.resolve(offset)))\n          }\n\n          return true\n        },\n      addColumnBefore:\n        () => ({ state, dispatch }) => {\n          return addColumnBefore(state, dispatch)\n        },\n      addColumnAfter:\n        () => ({ state, dispatch }) => {\n          return addColumnAfter(state, dispatch)\n        },\n      deleteColumn:\n        () => ({ state, dispatch }) => {\n          return deleteColumn(state, dispatch)\n        },\n      addRowBefore:\n        () => ({ state, dispatch }) => {\n          return addRowBefore(state, dispatch)\n        },\n      addRowAfter:\n        () => ({ state, dispatch }) => {\n          return addRowAfter(state, dispatch)\n        },\n      deleteRow:\n        () => ({ state, dispatch }) => {\n          return deleteRow(state, dispatch)\n        },\n      deleteTable:\n        () => ({ state, dispatch }) => {\n          return deleteTable(state, dispatch)\n        },\n      mergeCells:\n        () => ({ state, dispatch }) => {\n          return mergeCells(state, dispatch)\n        },\n      splitCell:\n        () => ({ state, dispatch }) => {\n          return splitCell(state, dispatch)\n        },\n      toggleHeaderColumn:\n        () => ({ state, dispatch }) => {\n          return toggleHeader('column')(state, dispatch)\n        },\n      toggleHeaderRow:\n        () => ({ state, dispatch }) => {\n          return toggleHeader('row')(state, dispatch)\n        },\n      toggleHeaderCell:\n        () => ({ state, dispatch }) => {\n          return toggleHeaderCell(state, dispatch)\n        },\n      mergeOrSplit:\n        () => ({ state, dispatch }) => {\n          if (mergeCells(state, dispatch)) {\n            return true\n          }\n\n          return splitCell(state, dispatch)\n        },\n      setCellAttribute:\n        (name, value) => ({ state, dispatch }) => {\n          return setCellAttr(name, value)(state, dispatch)\n        },\n      goToNextCell:\n        () => ({ state, dispatch }) => {\n          return goToNextCell(1)(state, dispatch)\n        },\n      goToPreviousCell:\n        () => ({ state, dispatch }) => {\n          return goToNextCell(-1)(state, dispatch)\n        },\n      fixTables:\n        () => ({ state, dispatch }) => {\n          if (dispatch) {\n            fixTables(state)\n          }\n\n          return true\n        },\n      setCellSelection:\n        position => ({ tr, dispatch }) => {\n          if (dispatch) {\n            const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell)\n\n            // @ts-ignore\n            tr.setSelection(selection)\n          }\n\n          return true\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Tab: () => {\n        if (this.editor.commands.goToNextCell()) {\n          return true\n        }\n\n        if (!this.editor.can().addRowAfter()) {\n          return false\n        }\n\n        return this.editor.chain().addRowAfter().goToNextCell().run()\n      },\n      'Shift-Tab': () => this.editor.commands.goToPreviousCell(),\n      Backspace: deleteTableWhenAllCellsSelected,\n      'Mod-Backspace': deleteTableWhenAllCellsSelected,\n      Delete: deleteTableWhenAllCellsSelected,\n      'Mod-Delete': deleteTableWhenAllCellsSelected,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    const isResizable = this.options.resizable && this.editor.isEditable\n\n    return [\n      ...(isResizable\n        ? [\n          columnResizing({\n            handleWidth: this.options.handleWidth,\n            cellMinWidth: this.options.cellMinWidth,\n            defaultCellMinWidth: this.options.cellMinWidth,\n            View: this.options.View,\n            lastColumnResizable: this.options.lastColumnResizable,\n          }),\n        ]\n        : []),\n      tableEditing({\n        allowTableNodeSelection: this.options.allowTableNodeSelection,\n      }),\n    ]\n  },\n\n  extendNodeSchema(extension) {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    return {\n      tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context)),\n    }\n  },\n})\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAgB,SAAA,uBAAuB,UAAkB,OAAyB;AAChF,MAAI,OAAO;AAET,WAAO,CAAC,SAAS,GAAG,KAAK,IAAI,OAAO,QAAQ,CAAC,IAAI;;AAInD,SAAO,CAAC,aAAa,GAAG,QAAQ,IAAI;AAEtC;SCJgB,cACd,MACA,UACA,OACA,cACA,aACA,eAAsB;;AAEtB,MAAI,aAAa;AACjB,MAAI,aAAa;AACjB,MAAI,UAAU,SAAS;AACvB,QAAM,MAAM,KAAK;AAEjB,MAAI,QAAQ,MAAM;AAChB,aAAS,IAAI,GAAG,MAAM,GAAG,IAAI,IAAI,YAAY,KAAK,GAAG;AACnD,YAAM,EAAE,SAAS,SAAQ,IAAK,IAAI,MAAM,CAAC,EAAE;AAE3C,eAAS,IAAI,GAAG,IAAI,SAAS,KAAK,GAAG,OAAO,GAAG;AAC7C,cAAM,WAAW,gBAAgB,MAAM,gBAAiB,YAAY,SAAS,CAAC;AAC9E,cAAM,WAAW,WAAW,GAAG,QAAQ,OAAO;AAE9C,sBAAc,YAAY;AAE1B,YAAI,CAAC,UAAU;AACb,uBAAa;;AAGf,YAAI,CAAC,SAAS;AACZ,gBAAM,aAAa,SAAS,cAAc,KAAK;AAE/C,gBAAM,CAAC,aAAa,aAAa,IAAI,uBAAuB,cAAc,QAAQ;AAElF,qBAAW,MAAM,YAAY,aAAa,aAAa;AAEvD,mBAAS,YAAY,UAAU;eAC1B;AACL,cAAK,QAAgC,MAAM,UAAU,UAAU;AAC7D,kBAAM,CAAC,aAAa,aAAa,IAAI,uBAAuB,cAAc,QAAQ;AAEjF,oBAAgC,MAAM,YAAY,aAAa,aAAa;;AAG/E,oBAAU,QAAQ;;;;;AAM1B,SAAO,SAAS;AACd,UAAM,QAAQ,QAAQ;AAEtB,KAAA,KAAA,QAAQ,gBAAU,QAAA,OAAA,SAAA,SAAA,GAAE,YAAY,OAAO;AACvC,cAAU;;AAGZ,MAAI,YAAY;AACd,UAAM,MAAM,QAAQ,GAAG,UAAU;AACjC,UAAM,MAAM,WAAW;SAClB;AACL,UAAM,MAAM,QAAQ;AACpB,UAAM,MAAM,WAAW,GAAG,UAAU;;AAExC;IAEa,kBAAS;EAapB,YAAY,MAAuB,cAAoB;AACrD,SAAK,OAAO;AACZ,SAAK,eAAe;AACpB,SAAK,MAAM,SAAS,cAAc,KAAK;AACvC,SAAK,IAAI,YAAY;AACrB,SAAK,QAAQ,KAAK,IAAI,YAAY,SAAS,cAAc,OAAO,CAAC;AACjE,SAAK,WAAW,KAAK,MAAM,YAAY,SAAS,cAAc,UAAU,CAAC;AACzE,kBAAc,MAAM,KAAK,UAAU,KAAK,OAAO,YAAY;AAC3D,SAAK,aAAa,KAAK,MAAM,YAAY,SAAS,cAAc,OAAO,CAAC;;EAG1E,OAAO,MAAqB;AAC1B,QAAI,KAAK,SAAS,KAAK,KAAK,MAAM;AAChC,aAAO;;AAGT,SAAK,OAAO;AACZ,kBAAc,MAAM,KAAK,UAAU,KAAK,OAAO,KAAK,YAAY;AAEhE,WAAO;;EAGT,eAAe,UAA4B;AACzC,WACE,SAAS,SAAS,iBACd,SAAS,WAAW,KAAK,SAAS,KAAK,SAAS,SAAS,SAAS,MAAM;;AAGjF;ACjFK,SAAU,eACd,MACA,cACA,aACA,eAAsB;AAEtB,MAAI,aAAa;AACjB,MAAI,aAAa;AACjB,QAAM,OAAwB,CAAA;AAC9B,QAAM,MAAM,KAAK;AAEjB,MAAI,CAAC,KAAK;AACR,WAAO,CAAA;;AAGT,WAAS,IAAI,GAAG,MAAM,GAAG,IAAI,IAAI,YAAY,KAAK,GAAG;AACnD,UAAM,EAAE,SAAS,SAAQ,IAAK,IAAI,MAAM,CAAC,EAAE;AAE3C,aAAS,IAAI,GAAG,IAAI,SAAS,KAAK,GAAG,OAAO,GAAG;AAC7C,YAAM,WAAW,gBAAgB,MAAM,gBAAgB,YAAY,SAAS,CAAC;AAE7E,oBAAc,YAAY;AAE1B,UAAI,CAAC,UAAU;AACb,qBAAa;;AAGf,YAAM,CAAC,UAAU,KAAK,IAAI,uBAAuB,cAAc,QAAQ;AAEvE,WAAK,KAAK;QACR;QACA,EAAE,OAAO,GAAG,QAAQ,KAAK,KAAK,GAAE;MACjC,CAAA;;;AAIL,QAAM,aAAa,aAAa,GAAG,UAAU,OAAO;AACpD,QAAM,gBAAgB,aAAa,KAAK,GAAG,UAAU;AAErD,QAAM,WAA0B,CAAC,YAAY,CAAA,GAAI,GAAG,IAAI;AAExD,SAAO,EAAE,UAAU,YAAY,cAAa;AAC9C;ACrEgB,SAAA,WACd,UACA,aAAiE;AAEjE,MAAI,aAAa;AACf,WAAO,SAAS,cAAc,MAAM,WAAW;;AAGjD,SAAO,SAAS,cAAa;AAC/B;ACTM,SAAU,kBAAkB,QAAc;AAC9C,MAAI,OAAO,OAAO,gBAAgB;AAChC,WAAO,OAAO,OAAO;;AAGvB,QAAM,QAAqC,CAAA;AAE3C,SAAO,KAAK,OAAO,KAAK,EAAE,QAAQ,UAAO;AACvC,UAAM,WAAW,OAAO,MAAM,IAAI;AAElC,QAAI,SAAS,KAAK,WAAW;AAC3B,YAAM,SAAS,KAAK,SAAS,IAAI;;EAErC,CAAC;AAED,SAAO,OAAO,iBAAiB;AAE/B,SAAO;AACT;ACfM,SAAU,YACd,QACA,WACA,WACA,eACA,aAAiE;AAEjE,QAAM,QAAQ,kBAAkB,MAAM;AACtC,QAAM,cAAiC,CAAA;AACvC,QAAM,QAA2B,CAAA;AAEjC,WAAS,QAAQ,GAAG,QAAQ,WAAW,SAAS,GAAG;AACjD,UAAM,OAAO,WAAW,MAAM,MAAM,WAAW;AAE/C,QAAI,MAAM;AACR,YAAM,KAAK,IAAI;;AAGjB,QAAI,eAAe;AACjB,YAAM,aAAa,WAAW,MAAM,aAAa,WAAW;AAE5D,UAAI,YAAY;AACd,oBAAY,KAAK,UAAU;;;;AAKjC,QAAM,OAA0B,CAAA;AAEhC,WAAS,QAAQ,GAAG,QAAQ,WAAW,SAAS,GAAG;AACjD,SAAK,KAAK,MAAM,IAAI,cAAc,MAAM,iBAAiB,UAAU,IAAI,cAAc,KAAK,CAAC;;AAG7F,SAAO,MAAM,MAAM,cAAc,MAAM,IAAI;AAC7C;ACrCM,SAAU,gBAAgB,OAAc;AAC5C,SAAO,iBAAiB;AAC1B;ACAO,IAAM,kCAA2D,CAAC,EAAE,OAAM,MAAM;AACrF,QAAM,EAAE,UAAS,IAAK,OAAO;AAE7B,MAAI,CAAC,gBAAgB,SAAS,GAAG;AAC/B,WAAO;;AAGT,MAAI,YAAY;AAChB,QAAM,QAAQ,2BAA2B,UAAU,OAAO,CAAC,EAAE,OAAO,UAAO;AACzE,WAAO,KAAK,KAAK,SAAS;EAC5B,CAAC;AAED,YAAK,QAAL,UAAK,SAAA,SAAL,MAAO,KAAK,YAAY,UAAO;AAC7B,QAAI,KAAK,KAAK,SAAS,SAAS;AAC9B,aAAO;;AAGT,QAAI,CAAC,aAAa,aAAa,EAAE,SAAS,KAAK,KAAK,IAAI,GAAG;AACzD,mBAAa;;EAEjB,CAAC;AAED,QAAM,mBAAmB,cAAc,UAAU,OAAO;AAExD,MAAI,CAAC,kBAAkB;AACrB,WAAO;;AAGT,SAAO,SAAS,YAAW;AAE3B,SAAO;AACT;ACqNa,IAAA,QAAQ,KAAK,OAAqB;EAC7C,MAAM;;EAGN,aAAU;AACR,WAAO;MACL,gBAAgB,CAAA;MAChB,WAAW;MACX,aAAa;MACb,cAAc;;MAEd,MAAM;MACN,qBAAqB;MACrB,yBAAyB;;;EAI7B,SAAS;EAET,WAAW;EAEX,WAAW;EAEX,OAAO;EAEP,YAAS;AACP,WAAO,CAAC,EAAE,KAAK,QAAO,CAAE;;EAG1B,WAAW,EAAE,MAAM,eAAc,GAAE;AACjC,UAAM,EAAE,UAAU,YAAY,cAAa,IAAK,eAC9C,MACA,KAAK,QAAQ,YAAY;AAG3B,UAAM,QAAuB;MAC3B;MACA,gBAAgB,KAAK,QAAQ,gBAAgB,gBAAgB;QAC3D,OAAO,aACH,UAAU,UAAU,KACpB,cAAc,aAAa;OAChC;MACD;MACA,CAAC,SAAS,CAAC;;AAGb,WAAO;;EAGT,cAAW;AACT,WAAO;MACL,aACE,CAAC,EAAE,OAAO,GAAG,OAAO,GAAG,gBAAgB,KAAI,IAAK,CAAA,MAAO,CAAC,EAAE,IAAI,UAAU,OAAM,MAAM;AAClF,cAAM,OAAO,YAAY,OAAO,QAAQ,MAAM,MAAM,aAAa;AAEjE,YAAI,UAAU;AACZ,gBAAM,SAAS,GAAG,UAAU,OAAO;AAEnC,aAAG,qBAAqB,IAAI,EACzB,eAAc,EACd,aAAa,cAAc,KAAK,GAAG,IAAI,QAAQ,MAAM,CAAC,CAAC;;AAG5D,eAAO;;MAEX,iBACE,MAAM,CAAC,EAAE,OAAO,SAAQ,MAAM;AAC5B,eAAO,gBAAgB,OAAO,QAAQ;;MAE1C,gBACE,MAAM,CAAC,EAAE,OAAO,SAAQ,MAAM;AAC5B,eAAO,eAAe,OAAO,QAAQ;;MAEzC,cACE,MAAM,CAAC,EAAE,OAAO,SAAQ,MAAM;AAC5B,eAAO,aAAa,OAAO,QAAQ;;MAEvC,cACE,MAAM,CAAC,EAAE,OAAO,SAAQ,MAAM;AAC5B,eAAO,aAAa,OAAO,QAAQ;;MAEvC,aACE,MAAM,CAAC,EAAE,OAAO,SAAQ,MAAM;AAC5B,eAAO,YAAY,OAAO,QAAQ;;MAEtC,WACE,MAAM,CAAC,EAAE,OAAO,SAAQ,MAAM;AAC5B,eAAO,UAAU,OAAO,QAAQ;;MAEpC,aACE,MAAM,CAAC,EAAE,OAAO,SAAQ,MAAM;AAC5B,eAAO,YAAY,OAAO,QAAQ;;MAEtC,YACE,MAAM,CAAC,EAAE,OAAO,SAAQ,MAAM;AAC5B,eAAO,WAAW,OAAO,QAAQ;;MAErC,WACE,MAAM,CAAC,EAAE,OAAO,SAAQ,MAAM;AAC5B,eAAO,UAAU,OAAO,QAAQ;;MAEpC,oBACE,MAAM,CAAC,EAAE,OAAO,SAAQ,MAAM;AAC5B,eAAO,aAAa,QAAQ,EAAE,OAAO,QAAQ;;MAEjD,iBACE,MAAM,CAAC,EAAE,OAAO,SAAQ,MAAM;AAC5B,eAAO,aAAa,KAAK,EAAE,OAAO,QAAQ;;MAE9C,kBACE,MAAM,CAAC,EAAE,OAAO,SAAQ,MAAM;AAC5B,eAAO,iBAAiB,OAAO,QAAQ;;MAE3C,cACE,MAAM,CAAC,EAAE,OAAO,SAAQ,MAAM;AAC5B,YAAI,WAAW,OAAO,QAAQ,GAAG;AAC/B,iBAAO;;AAGT,eAAO,UAAU,OAAO,QAAQ;;MAEpC,kBACE,CAAC,MAAM,UAAU,CAAC,EAAE,OAAO,SAAQ,MAAM;AACvC,eAAO,YAAY,MAAM,KAAK,EAAE,OAAO,QAAQ;;MAEnD,cACE,MAAM,CAAC,EAAE,OAAO,SAAQ,MAAM;AAC5B,eAAO,aAAa,CAAC,EAAE,OAAO,QAAQ;;MAE1C,kBACE,MAAM,CAAC,EAAE,OAAO,SAAQ,MAAM;AAC5B,eAAO,aAAa,EAAE,EAAE,OAAO,QAAQ;;MAE3C,WACE,MAAM,CAAC,EAAE,OAAO,SAAQ,MAAM;AAC5B,YAAI,UAAU;AACZ,oBAAU,KAAK;;AAGjB,eAAO;;MAEX,kBACE,cAAY,CAAC,EAAE,IAAI,SAAQ,MAAM;AAC/B,YAAI,UAAU;AACZ,gBAAM,YAAY,cAAc,OAAO,GAAG,KAAK,SAAS,YAAY,SAAS,QAAQ;AAGrF,aAAG,aAAa,SAAS;;AAG3B,eAAO;;;;EAKf,uBAAoB;AAClB,WAAO;MACL,KAAK,MAAK;AACR,YAAI,KAAK,OAAO,SAAS,aAAY,GAAI;AACvC,iBAAO;;AAGT,YAAI,CAAC,KAAK,OAAO,IAAG,EAAG,YAAW,GAAI;AACpC,iBAAO;;AAGT,eAAO,KAAK,OAAO,MAAK,EAAG,YAAW,EAAG,aAAY,EAAG,IAAG;;MAE7D,aAAa,MAAM,KAAK,OAAO,SAAS,iBAAgB;MACxD,WAAW;MACX,iBAAiB;MACjB,QAAQ;MACR,cAAc;;;EAIlB,wBAAqB;AACnB,UAAM,cAAc,KAAK,QAAQ,aAAa,KAAK,OAAO;AAE1D,WAAO;MACL,GAAI,cACA;QACA,eAAe;UACb,aAAa,KAAK,QAAQ;UAC1B,cAAc,KAAK,QAAQ;UAC3B,qBAAqB,KAAK,QAAQ;UAClC,MAAM,KAAK,QAAQ;UACnB,qBAAqB,KAAK,QAAQ;SACnC;MACF,IACC,CAAA;MACJ,aAAa;QACX,yBAAyB,KAAK,QAAQ;OACvC;;;EAIL,iBAAiB,WAAS;AACxB,UAAM,UAAU;MACd,MAAM,UAAU;MAChB,SAAS,UAAU;MACnB,SAAS,UAAU;;AAGrB,WAAO;MACL,WAAW,aAAa,kBAAkB,WAAW,aAAa,OAAO,CAAC;;;AAG/E,CAAA;",
  "names": []
}
